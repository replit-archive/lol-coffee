###
A virtual machine for the LOLCoffee compiler. Defines the instructions that can
be generated by the parse tree nodes and a simple machine interface. The machine
supports loading multiple programs, blocking for asynchronous external calls and
single-step execution.

Example usage:
  codegen_context = ...

  input_callback = ->
    $.get 'input.txt', (text) -> 
      machine.resume text

  output_callback = (output) ->
    $('#result')[0].value += output
    machine.resume()

  halt_callback = ->
    console.log 'Mahine halted. Loading new program...'
    # Generate code for a new program using codegen_context.
    machine.run()

  error_callback = (error) ->
    console.assert error instanceof LOLCoffee.MachineError
    console.log error

  machine = new LOLCoffee.Machine codegen_context,
                                  input_callback,
                                  output_callback,
                                  error_callback,
                                  halt_callback
  machine.run()

Provides:
  LOLCoffee.Machine
  LOLCoffee.MachineError
  LOLCoffee.Instructions

Requires:
  LOLCoffee.DEFAULT_VALUES
###

DEFAULT_VALUES = @LOLCoffee.DEFAULT_VALUES

# The type of error thrown by the virtual machine during execution.
class MachineError extends Error
  constructor: (message) ->
    @message = message + '.'
  name: 'MachineError'

# A type-tagged value that can be stored in a variable or the stack.
class Value
  constructor: (@type, @value) ->

  # Returns whether this value is equal to another, using the LOLCODE comparison
  # rules defined in teh 1.2 spec.
  equal: (other) ->
    if @type in ['float', 'int'] and other.type in ['float', 'int']
      return @value == other.value
    else if @type == other.type
      return @value == other.value
    else
      return false

  # Returns a new Value resulting from casting this value to the specified type
  # using the LOLCODE casting rules defined in teh 1.2 spec. If explicit is set,
  # null is allowed to be casted, returning the default value of the given type.
  cast: (to_type, explicit = false) ->
    if to_type is 'null' then throw new MachineError 'Cannot cast to NOOB'
    result = null
    switch @type
      when 'null'
        if explicit
          if to_type not of DEFAULT_VALUES
            throw new MachineError 'Unknown type: ' + to_type
          result = DEFAULT_VALUES[to_type]
        else
          unless to_type is 'bool'
            throw new MachineError 'Cannot implicitly cast NOOB to ' + to_type
          result = false
      when 'bool'
        result = switch to_type
          when 'bool' then @value
          when 'int', 'float' then Number @value
          when 'string' then (if @value then 'WIN' else 'FAIL')
          else throw new MachineError 'Unknown type: ' + to_type
      when 'int'
        result = switch to_type
          when 'bool' then @value != 0
          when 'int', 'float' then @value
          when 'string' then String @value 
          else throw new MachineError 'Unknown type: ' + to_type
      when 'float'
        result = switch to_type
          when 'bool' then @value != 0
          when 'int' then Math.floor @value
          when 'float' then @value
          when 'string' then String @value 
          else throw new MachineError 'Unknown type: ' + to_type
      when 'string'
        result = switch to_type
          when 'bool' then @value != ''
          when 'int'
            unless /^-?\d+$/.test @value
              throw new MachineError "Cannot parse NUMBR from '#{@value}'"
            parseInt @value, 10
          when 'float'
            unless /^-?(\d+(\.\d*)?|\.\d+)$/.test @value
              throw new MachineError "Cannot parse NUMBAR from '#{@value}'"
            parseFloat @value
          when 'string' then @value
          else throw new MachineError 'Unknown type: ' + to_type
      else throw new MachineError 'Unknown type: ' + @type
    return new Value to_type, result

# A frame object that keeps track of the stack and instruction pointers, as well
# as providing a variable scope.
class Frame
  constructor: (@name, @instruction_ptr) ->
    @variables = {}
    @stack = []

# A halt instruction. Sets the machine halted flag and calls the done callback.
class Halt
  exec: (machine) ->
    machine.halted = true
    machine.done()

# An unconditional jump instruction. Moves the instruction pointer to the
# address of its label.
# IP = [label]
class Jump
  constructor: (@label) ->
  exec: (machine) ->
    machine.instruction_ptr = machine.labels[@label]

# A conditional jump instruction. Jumps to its label if the item popped from the
# stack is false.
class JumpIfZero
  constructor: (@label) ->
  exec: (machine) ->
    if machine.getStack().pop().value == false
      machine.instruction_ptr = machine.labels[@label]

# A function declaration instruction. Binds a function name to its address.
class DeclareFunction
  constructor: (@name, @label) ->
  exec: (machine) ->
    machine.functions[@name] = machine.labels[@label]

# A variable declaration instruction. Binds its identifier to a new null value
# in the nearest frame.
class DeclareVariable
  constructor: (@identifier) ->
  exec: (machine) ->
    if @identifier is 'IT'
      throw new MachineError 'Cannot declare the special variable IT'
    top_frame = machine.frames[-1..][0]
    top_frame.variables[@identifier] = new Value 'null', null

# An assinment instruction. Sets the value of its variable to the value popped
# from the stack. If the variable is declared in the local (top) frame, changes
# it there. Otherwise in the global (bottom) frame. The variable must have been
# previously declared using a DeclareVariable instruction.
class Assign
  constructor: (@identifier) ->
  exec: (machine) ->
    global_vars = machine.frames[0].variables
    local_vars = machine.frames[-1..][0].variables
    value = machine.getStack().pop()

    if @identifier of local_vars
      local_vars[@identifier] = value
    else if @identifier of global_vars
      global_vars[@identifier] = value
    else if machine.auto_declare
      local_vars[@identifier] = value
    else
      throw new MachineError 'Assignment to undefined variable: ' + @identifier

# An assinment-at-index instruction. Sets the value of its variable at the index
# popped from the stack to the value popped from the stack. Uses the same lookup
# rules as Assign.
class AssignAtIndex
  constructor: (@identifier) ->
  exec: (machine) ->
    global_vars = machine.frames[0].variables
    local_vars = machine.frames[-1..][0].variables

    if @identifier of local_vars
      scope = local_vars
    else if @identifier of global_vars
      scope = global_vars
    else if machine.auto_declare
      scope = local_vars
    else
      throw new MachineError 'Assignment to undefined variable: ' + @identifier

    base = scope[@identifier]
    index = machine.getStack().pop()
    value = machine.getStack().pop()

    if base.type isnt 'string'
      throw new MachineError 'Can only index YARNs, not ' + base.type
    if index.type isnt 'int'
      throw new MachineError 'Can only index using NUMBRs, not ' + index.type
    if index.value >= base.value.length
      throw new MachineError "Out of bounds: '#{base.value}'[#{index.value}]"
    if value.type isnt 'string' or value.value.length isnt 1
      throw new MachineError('Can only assign single-character YARNs to YARN ' +
                             'indices, not ' + value.value)

    base = base.value
    result = base[...index.value] + value.value + base[index.value + 1..]
    scope[@identifier] = new Value 'string', result

# An input instruction. Pauses the machine and calls its input callback.
class Input
  exec: (machine) ->
    machine.pause()
    machine.input()

# An output instruction. Pauses the machine and calls its output callback
# passing a value popped from the stack.
class Output
  exec: (machine) ->
    machine.pause()
    machine.output machine.getStack().pop().value

# A syscall result receiving instruction. Pushes the value of the machine's last
# syscall result onto the stack.
class PushSyscallResult
  exec: (machine) ->
    result = machine.syscall_result
    result = if result then String result else ''
    machine.getStack().push new Value 'string', result

# A variable lookup instruction. Pushes the value bound to a variable onto the
# stack. Checks the local (top) frame then the global (bottom) frame. Fails if
# the variable has not been declared in either.
class PushVariable
  constructor: (@identifier) ->
  exec: (machine) ->
    global_vars = machine.frames[0].variables
    local_vars = machine.frames[-1..][0].variables

    if @identifier of local_vars
      value = local_vars[@identifier]
    else if @identifier of global_vars
      value = global_vars[@identifier]
    else
      throw new MachineError 'Reference to undefined variable: ' + @identifier
    machine.getStack().push value

# An indexing instruction. Pops base and index and pushes the index'th character
# of the base.
class GetIndex
  constructor: ->
  exec: (machine) ->
    base = machine.getStack().pop()
    index = machine.getStack().pop()
    if base.type isnt 'string'
      throw new MachineError 'Can only index YARNs, not ' + base.type
    if index.type isnt 'int'
      throw new MachineError 'Can only index using NUMBRs, not ' + index.type
    if index.value >= base.value.length
      throw new MachineError "Out of bounds: '#{base.value}'[#{index.value}]"
    machine.getStack().push new Value 'string', base.value[index.value]

# A literal pushing instruction. Pushes a typed literal value onto the stack.
class PushLiteral
  constructor: (@type, @value) ->
  exec: (machine) ->
    machine.getStack().push new Value @type, @value

# A cast instruction. Casts the top of the stack into the specified type.
class Cast
  constructor: (@type, @explicit = false) ->
  exec: (machine) ->
    machine.getStack().push machine.getStack().pop().cast @type, @explicit

# A call instruction. Pushes a new frame and jumps to the specified function.
class Call
  constructor: (@func_name, @args_count) ->
  exec: (machine) ->
    old_stack = machine.getStack()
    machine.frames.push new Frame @func_name, machine.instruction_ptr
    for _ in [0...@args_count]
      machine.getStack().push old_stack.pop()
    machine.getStack().reverse()
    machine.instruction_ptr = machine.functions[@func_name]

# A return instruction. Pops the return value and the top frame, jumps to the
# call site, adjusts the stack back to the offset where it was during the call
# and finally pushes the result back into the stack.
class Return
  exec: (machine) ->
    result = machine.getStack().pop()
    frame = machine.frames.pop()
    machine.instruction_ptr = frame.instruction_ptr
    machine.getStack().push result

# An n-ary all operator instruction. Pops its N operands off the stack and
# pushes a boolean value indicating whether all the of the operands are true in
# a boolean context.
class All
  constructor: (@args_count) ->
  exec: (machine) ->
    args = for _ in [0...@args_count]
      machine.getStack().pop().cast('bool').value
    result = true
    for arg in args
      unless arg then result = false; break
    machine.getStack().push new Value 'bool', result

# An n-ary any operator instruction. Pops its N operands off the stack and
# pushes a boolean value indicating whether at least one of its operands is true
# in a boolean context.
class Any
  constructor: (@args_count) ->
  exec: (machine) ->
    args = for _ in [0...@args_count]
      machine.getStack().pop().cast('bool').value
    result = false
    for arg in args
      if arg then result = true; break
    machine.getStack().push new Value 'bool', result

# An n-ary concatenation operator instruction. Pops its N operands off the
# stack, casts them to strings, concatenates them and pushes the resulting
# string onto the stack.
class Concat
  constructor: (@args_count) ->
  exec: (machine) ->
    args = for _ in [0...@args_count]
      machine.getStack().pop().cast('string').value
    machine.getStack().push new Value 'string', args.join ''

# An abstract base class for binary mathematical operator instructions. Provides
# an exec() method that wraps any binary math operation with the correct casting
# to float/int as per the LOLCODE 1.2 spec.
class MathOperation
  exec: (machine, operation) ->
    left = machine.getStack().pop()
    right = machine.getStack().pop()
    type = if 'float' in [left.type, right.type] then 'float' else 'int'
    left = left.cast(type).value
    right = right.cast(type).value
    result = operation left, right
    if type is 'int' then result = Math.floor result
    machine.getStack().push new Value type, result

# A binary addition operator instruction. Pops two values and pushes their sum.
class Add extends MathOperation
  exec: (machine) ->
    super machine, (x, y) -> x + y

# A binary subtraction operator instruction. Pops two values and pushes their
# difference.
class Subtract extends MathOperation
  exec: (machine) ->
    super machine, (x, y) -> x - y

# A binary multiplication operator instruction. Pops two values and pushes
# their product.
class Multiply extends MathOperation
  exec: (machine) ->
    super machine, (x, y) -> x * y

# A binary division operator instruction. Pops two values and pushes the
# quotient from their division.
class Divide extends MathOperation
  exec: (machine) ->
    super machine, (x, y) -> x / y

# A binary modulo operator instruction. Pops two values and pushes the
# remainder from their division.
class Modulo extends MathOperation
  exec: (machine) ->
    super machine, (x, y) -> x % y

# A binary maximum operator instruction. Pops two values and pushes the larger.
class Max extends MathOperation
  exec: (machine) ->
    super machine, (x, y) -> if x > y then x else y

# A binary maximum operator instruction. Pops two values and pushes the
# smaller.
class Min extends MathOperation
  exec: (machine) ->
    super machine, (x, y) -> if x < y then x else y

# An abstract base class for binary boolean operator instructions. Provides
# an exec() method that wraps any binary boolean operation.
class BoolOperation
  exec: (machine, operation) ->
    left = machine.getStack().pop().cast('bool').value
    right = machine.getStack().pop().cast('bool').value
    machine.getStack().push new Value 'bool', operation left, right

# A binary boolean "and" operator instruction. Pops two values and pushes a
# true value if both of them are true and a false value otherwise.
class And extends BoolOperation
  exec: (machine) ->
    super machine, (x, y) -> x and y

# A binary boolean "or" operator instruction. Pops two values and pushes a
# true value if either of them is true and a false value otherwise.
class Or extends BoolOperation
  exec: (machine) ->
    super machine, (x, y) -> x or y

# A binary boolean "xor" operator instruction. Pops two values and pushes a
# true value if the two values are unequal in boolean context and a false value
# otherwise.
class Xor extends BoolOperation
  exec: (machine) ->
    super machine, (x, y) -> x ^ y

# A binary equality operator instruction. Pops two values and pushes a true
# value if the two values are equal as per the LOLCODE 1.2 comparison rules.
class Equal
  exec: (machine) ->
    left = machine.getStack().pop()
    right = machine.getStack().pop()
    machine.getStack().push new Value 'bool', left.equal right

# A binary inequality operator instruction. Pops two values and pushes a true
# value if the two values are not equal as per the LOLCODE 1.2 comparison rules.
class Unequal
  exec: (machine) ->
    left = machine.getStack().pop()
    right = machine.getStack().pop()
    machine.getStack().push new Value 'bool', not left.equal right

# A unary boolean invertion operator instruction. Casts the top of the stack
# into a boolean and inverts it.
class Invert
  exec: (machine) ->
    operand = machine.getStack().pop().cast('bool').value
    machine.getStack().push new Value 'bool', not operand

# A unary length operator instruction. Pushes the length of the value popped
# from the stack.
class GetLength
  exec: (machine) ->
    operand = machine.getStack().pop()
    if operand.type isnt 'string'
      throw new MachineError 'Can only get length of YARNs'
    machine.getStack().push new Value 'int', operand.value.length

# A unary character code conversion operator instruction. Pushes the character
# expressed by the character code popped from the stack.
class FromCharCode
  exec: (machine) ->
    operand = machine.getStack().pop()
    if operand.type isnt 'int'
      throw new MachineError('Character codes must be NUMBRs, not ' +
                             operand.type)
    str = String.fromCharCode operand.value
    machine.getStack().push new Value 'string', str

# A unary character code conversion operator instruction. Pushes the character
# code of the character at the beginning of the string popped from the stack.
class ToCharCode
  exec: (machine) ->
    operand = machine.getStack().pop()
    if operand.type isnt 'string' or not operand.value.length
      throw new MachineError('Can only take character code of non-empty ' + 
                             "YARNs, not '#{operand.type}'")
    machine.getStack().push new Value 'int', operand.value.charCodeAt 0

# A virtual machine for running LOLCoffee instructions. The constructor receives
# a codegen context and an optional set of callbacks for I/O, error reporting
# and halt notification. If auto_declare is provided and true, assignments to
# undeclared variables automatically create local declarations. This is useful
# in REPL contexts. It can also Programs generated in the provided context are
# automatically loaded and ready for execution. The context is used only for
# reading so it is safe to use a single context for multiple machines.
class Machine
  constructor: (@context, @input, @output, @error, @done, @auto_declare) ->
    # Live references to the instructions and labels of the context.
    @instructions = @context.instructions
    @labels = @context.labels
    # Initialize machine-specific state.
    @reset()
    # Default settings.
    @input = @input or => @resume()
    @output = @output or => @resume()
    @error = @error or ->
    @done = @done or ->
    @auto_declare = @auto_declare or false

  # Resets the machine's state, e.g. to recover from errors and restart.
  reset: ->
    @instruction_ptr = 0
    @frames = [new Frame '{MAIN}', 0]
    @frames[0].variables.IT = new Value 'null', null
    @functions = {}
    @halted = true
    @blocked = false
    @syscall_result = null

  # Executes the next instruction and increments the instruction pointer.
  step: ->
    if @blocked or @halted or @instruction_ptr >= @instructions.length
      throw new MachineError 'Cannot execute while blocked, halted or at end'
    try
      @instructions[@instruction_ptr++].exec @
    catch e
      @error e
      @halted = true

  # Starts the machine and continues running until blocked or halted.
  run: ->
    @halted = false
    @step() until @blocked or @halted

  # Blocks the machine until resumed, e.g. for asynchronous external calls.
  pause: ->
    @blocked = true

  # Resumes after having been paused, e.g. for asynchronous external calls.
  # Optionally accepts a value to be used as the syscall result.
  resume: (syscall_result = null) ->
    @syscall_result = syscall_result
    @blocked = false
    @run() unless @halted

  # Returns a reference to the stack of the nearest frame.
  getStack: ->
    return @frames[@frames.length - 1].stack

# Exports.
@LOLCoffee.Machine = Machine
@LOLCoffee.MachineError = MachineError
@LOLCoffee.Instructions =
  Halt: Halt
  PushLiteral: PushLiteral
  DeclareFunction: DeclareFunction
  Jump: Jump
  DeclareVariable: DeclareVariable
  Assign: Assign
  AssignAtIndex: AssignAtIndex
  Return: Return
  Input: Input
  PushSyscallResult: PushSyscallResult
  Output: Output
  PushVariable: PushVariable
  GetIndex: GetIndex
  Cast: Cast
  JumpIfZero: JumpIfZero
  Call: Call
  All: All
  Any: Any
  Concat: Concat
  Add: Add
  Subtract: Subtract
  Multiply: Multiply
  Divide: Divide
  Modulo: Modulo
  Max: Max
  Min: Min
  And: And
  Or: Or
  Xor: Xor
  Equal: Equal
  Unequal: Unequal
  Invert: Invert
  GetLength: GetLength
  FromCharCode: FromCharCode
  ToCharCode: ToCharCode
